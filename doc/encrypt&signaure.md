# 签名/加密机制

**签名，就是是给信息加个身份，证明这段信息的发布者和这段信息的有效性完整性。所有的接受者都可以知道发送方。**

**加密，是对信息的加密，防止数据泄露，保证数据的安全性，只有拥有私钥的接收方才能解密。**

这里的签名、加密指的是应用非对称加密算法，保证双方数据传输的认证机制和安全保密机制，

通常使用服务端公钥加密、私钥解密、客户端私钥签名、公钥验签。


## 一、加密简介

### 描述

以对称/非对称算法，明文变密文，防止数据泄露

### 1.1 对称密钥加密

#### 定义

指加密解密使用相同的密钥。
* 优: 使用简单快捷高效。
* 缺: 加密强度不高，密钥分发困难

#### 应用
通常用于少量点对点的通讯加密，通讯方之间隐私地保存密钥，如文件加密和解密

#### 常见对称加密算法
* DES: 对称加密算法的基石，不再安全，一种分组加密算法。密钥固定64位(实际参与加密56位)，采用替换和移位，每次对64位数据块加密。
* 3DES: 对明文进行三次DES加密，安全性提升，效率降低。密钥192位，在加密和解密时，密钥会被分为3个64位的密钥。
* AES: 高级加密标准。最常用的对称加密算法。密钥长度固定(可以是128/192/256位)，也是一种分组加密算法，其分组长度只能是128位。密钥建立时间短、灵敏性好、内存需求低，有多种模式。
* RC5: 一种分组加密算法； RC4: 流加密算法
* IDEA: 常用的电子邮件加密算法，工作模式只有ECB，密钥长度128位，每次对64位数据块加密。

### 1.2 非对称密钥加密

#### 定义

一个公钥一个私钥，加密使用公钥，解密使用私钥

优缺点：
* 优:解决了加密强度不高，密钥分发困难的问题
* 缺:加密速度慢

#### 应用

通常用于服务提供商提供某种服务给外部客户，如阿里的支付接口

#### 常见非对称加密

* RSA: 512位密钥，计算量大，难破解。用于对称密钥交换、数字签名、数据加密
* DSA: 数字签名算法，只用于数字签名
* ECC: 椭圆曲线密码算法，性能优越，包括处理速度，带宽要求，存储空间等
* DH: 


### 1.3 Hash散列（不可逆）

把任意长度的输入消息串变化成固定长的输出串，且难以由输出串得到输入串

一般用于消息摘要，文件数据指纹，创建数字签名，密码加密等

#### 应用
* 文件生产摘要，唯一值。
* 服务器的密码保护，不直接将密码明文存入数据库，而是将密码hash值存入数据库。
* 防止数据被篡改。将传输的数据生成hash值后，在对散列值进行签名。 然后在接收端对签名进行校验。
* 云盘秒传。只要上传文件的散列值在服务器存有，就不需要上传的步骤。

#### 常用种类
* MD系列: 
  * md2、md4、md5，其中最常用MD5算法: 输入任意长度字符，输出固定长度128位
  * md5+salt:
    * 简单的md5密码加密，可以通过大量样本密码md5比较，可以轻松试出密码。
    * 如果加上salt，即密码散列加密之前做字符串拼接上salt,然后再散列。
    * 黑客用自己密码和salt值试，就很难找到密码。
* sha系列:
  * sha1: 2017年实现了碰撞破解，不再安全
  * sha2:
    * SHA-224
    * SHA-256: 广泛应用于SSL数字证书和代码签名证书签名
    * SHA-384
    * SHA-512
  * sha3: 更安全
    * 


### 数字加密

采用了对称密钥加密算法或者非对称密钥加密算法，它能保证发送信息保密性。



## 二、基于非对称加密算法的加密

### 描述

A给B发送信息，A使用B的公钥进行信息加密，B收到后用自己的私钥解密，获取A发送的原始信息。


### 非对称加密的漏洞 ---> 中间人攻击

过程描述：
* 服务端生成一对公钥私钥，并将公钥公布给客户端
* 但是若黑客截获公钥，并将自己的公钥(黑客自己可以生成一对公私钥)发给了客户端
* 于是客户端就用黑客的公钥进行数据加密，并向服务端发送请求
* 然而客户端请求又被黑客截获，黑客用自己的私钥解密获得客户端真实发送的源数据，篡改伪造后用服务端的公钥加密发给服务端
* 服务端解密后获得的数据是黑客篡改的数据

### 防止中间人攻击

由上漏洞而知，服务端解密后得到的数据是经过中间人篡改的。根本不能被信任。

解决方式：
* 使用消息认证，就是用证书(数字签名)，即采取HTTPS的方式。
* checksum文件校验和也是用来防止中间人攻击的
* ...



## 三、签名

双方通信的认证机制

签名通常是使用非对称加密算法来实现的，并应用了hash散列

ps: 认证技术包括三个：
* 身份认证
* 消息认证（解决中间人攻击）
* 数字签名（解决通信双方的抵赖）

**！！！通常指的是基于非对称算法的签名，也称数字签名，或者说CA证书**

### 描述

A给B发送信息，A使用自己的私钥签名，B收到后用A的公钥验签，来确认是不是A发的。

### 数字签名的缺陷

接收方得到的消息虽然不能被篡改，但是消息的内容可以利用公钥验签来获得，并不能防止泄露。因此一般需要结合加密。

### 数字签名的本质

其实就是 数据哈希 + 非对称加密

由于签名无需还原成明文，因此可以在加密前进行哈希处理。而验签就是哈希+解密+比较。

* 签名过程：对明文做哈希，再用私钥对哈希进行加密，得到签名。将明文、签名一起发送出去
* 验签过程：接收者用公钥解密签名得到哈希值，同时对原明文做哈希，比较两者哈希值是否相同，相同则验签成功。

为什么签名是对信息hash之后加密，而不是加密一些特定的字符？

这是因为防止中间人攻击，黑客尝试向私钥拥有者反复发送一些特定的字符，得到加密后的信息，达到破解或者伪造之类的目的。所以用私钥随便加密信息是不安全的。


### 常见签名算法
Rabin签名 DSS签名。
* RSA签名算法
* DSA数字签名算法: 
  * 和RSA不同之处在于它不能用作加密和解密，也不能进行密钥交换，只用于签名，所以它比RSA要快很多，其安全性与RSA相比差不多
  * 一个重要特点是两个素数公开，这样，当使用别人的p和q时，即使不知道私钥，你也能确认它们是否是随机产生的，还是作了手脚。RSA算法却做不到
* ECDSA
* PGP数字签名基于RSA非对称加密。



## 三、签名与加密对比与结合使用

### 对比
1. 签名用于确认信息的身份，防止信息被篡改；加密用于保证数据的安全，防止信息被泄露
2. 加密是可逆的，而签名是不可逆的。
3. 数据加密保证了数据接受方的数据安全性。数据签名保证了数据发送方的数据安全性。

### 加密签名结合

1. 客户端生成公私钥对用作签名，服务端生成公私钥对用作加密
2. 客户端使用服务端公钥加密、用自己的私钥签名后发送给服务端
3. 服务端使用客户端的公钥验签、用自己的私钥解密获取客户端发送原数据。
4. 签名与加密的结合保证了端到端的唯一确认

### HTTPS签名加密机制(HTTP + SSL/TLS)

https://www.cnblogs.com/sxiszero/p/11133747.html

#### CA证书

CA证书又名公钥证书，由权威CA机构发布

#### 拥有CA证书的发送消息过程：
* 消息接受者Bob 生成秘钥对， 然后将自己的公钥发送给CA机构
* CA机构通过一系列手段，进行验证。确认后 用CA的私钥 将Bob的公钥和其个人信息一并 进行数字签名（就是证书），然后放在仓库供使用者下载
* Alice从CA机构下载得到Bob的证书， 然后用CA的公钥进行解密验证。 验证成功后得到 Bob的公钥
* 消息发送者Alice 将 将要发送的消息用hash函数 --> 生成摘要 --> 再用Bob的公钥进行非对称加密 --> 生成一段加密后的文字 和 原来的消息（明文） 一并发送出去
* 消息接受者Bob 用 自己的私钥对密文 解密得到散列值，再同 消息本身生成的散列值进行对比，来判断消息是否完整与是否是 发送者本人发送的消息。

#### HTTPS工作原理
1. client向server发送请求https://baidu.com，然后连接到server的443端口。

2. 服务端必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥。

3. 传送证书

   这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。

4. 客户端解析证书

   这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值（密钥）。然后用证书对该随机值进行加密。

5. 传送加密信息

   这部分传送的是用证书加密后的密钥（随机值），目的就是让服务端得到这个密钥，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。

6. 服务端加密信息

   服务端用私钥解密，得到了客户端传过来的密钥，然后把内容通过该值进行对称加密。

7. 传输加密后的信息

   这部分信息是服务端用密钥对称加密后的信息，可以在客户端被还原。

8. 客户端解密信息

   客户端用之前生成的密钥解密服务端传过来的信息，于是获取了解密后的内容。






