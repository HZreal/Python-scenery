# 同步异步

## 阻塞

- 程序未得到所需计算资源时被挂起的状态。
- **程序在等待某个操作完成期间，自身无法继续干别的事情，则称该程序在该操作上是阻塞的。**
- 常见的阻塞形式有：网络I/O阻塞、磁盘I/O阻塞、用户输入阻塞等。

## 非阻塞

- **程序在等待某操作过程中，自身不被阻塞，可以继续运行干别的事情，则称该程序在该操作上是非阻塞的。**
- 非阻塞并**不是**在任何程序级别、任何情况下都可以存在的。
- 仅当程序封装的级别可以囊括独立的子程序单元时，它才可能存在非阻塞状态。

正因为某个操作阻塞导致的耗时与效率低下，我们才要把它变成非阻塞的。

## 同步

- 不同程序单元为了完成某个任务，在执行过程中需靠某种通信方式以**协调一致**，称这些程序单元是同步执行的。
- 例如购物系统中更新商品库存，需要用“行锁”作为通信信号，让不同的更新请求强制排队顺序执行，那更新库存的操作是同步的。
- 简言之，**同步意味着有序**。

## 异步

- 为完成某个任务，不同程序单元之间**过程中无需通信协调**，也能完成任务的方式。
- 不相关的程序单元之间可以是异步的。
- 例如，爬虫下载网页。调度程序调用下载程序后，即可调度其他任务，而无需与该下载任务保持通信以协调行为。不同网页的下载、保存等操作都是无关的，也无需相互通知协调。这些异步操作的完成时刻并不确定。
- 简言之，**异步意味着无序**。

## 并发

- 并发描述的是程序的组织结构。指程序要被设计成多个可独立执行的子任务。
- **以利用有限的计算机资源使多个任务可以被实时或近实时执行为目的。**

## 并行

- 并行描述的是程序的执行状态。指多个任务同时被执行。
- **以利用富余计算资源（多核CPU）加速完成多个任务为目的。**

## 概念总结

- **并行**是为了利用多核加速多任务完成的进度
- **并发**是为了让独立的子任务都有机会被尽快执行，但不一定能加速整体进度
- **非阻塞**是为了提高程序整体执行效率
- **异步**是高效地组织非阻塞任务的方式

## 异步编程

**以进程、线程、协程、函数/方法作为执行任务程序的基本单位，结合回调、事件循环、信号量等机制，以提高程序整体执行效率和并发能力的编程方式。**

同步/异步、阻塞/非阻塞并非水火不容，要看讨论的程序所处的封装级别。例如购物程序在处理多个用户的浏览请求可以是异步的，而更新库存时必须是同步的。

## CPU的时间观

http://mmbiz.qpic.cn/mmbiz_png/u7em1R1IeaGqcia6PWK3VKKb7LpfNJItr57yib1FqnUl0AvJdtbq1KGrnZtJ5iawgaQ2ib3LOZKmHTov6icUXK6Iiapg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1

从CPU的时间观中可知，**网络I/O是最大的I/O瓶颈**，除了宕机没有比它更慢的。所以，诸多异步框架都对准的是网络I/O。

## 异步I/O进化之路

https://mp.weixin.qq.com/s?__biz=MzIxMjY5NTE0MA==&mid=2247483720&idx=1&sn=f016c06ddd17765fd50b705fed64429c

需求：下载多个文件

### 同步阻塞下载

最传统的解决方案就是同步依次下载，从建立socket连接到发送网络请求再到读取响应数据，顺序进行。

### 多进程下载

每个文件都启动一个进程下载，改善效率立竿见影，但总体耗时并没有缩减到原来的十分之一，而是九分之一左右，还有一些时间耗到哪里去了？**进程切换开销**。

进程切换开销不止像“CPU的时间观”所列的“上下文切换”那么低。CPU从一个进程切换到另一个进程，需要把旧进程运行时的寄存器状态、内存状态全部保存好，再将另一个进程之前保存的数据恢复。对CPU来讲，几个小时就干等着。**切换开销大**

一般的服务器在能够稳定运行的前提下，可以同时处理的进程数在数十个到数百个规模。如果进程数量规模更大，系统运行将不稳定，而且可用内存资源往往也会不足。

### 多线程下载

线程的数据结构比进程更轻量级，**切换开销比进程切换开销小得多、耗时也更少。**

后来的OS也把调度单位由进程转为线程，进程只作为线程的容器，用于管理进程所需的资源。而且OS级别的线程是可以被分配到不同的CPU核心同时运行的。

但是，多线程仍有问题，特别是Python里的多线程。首先，Python中的多线程因为GIL的存在，它们并不能利用CPU多核优势，**一个Python进程中，只允许有一个线程处于运行状态**。那为什么结果还是如预期，耗时缩减到了十分之一？

因为在做阻塞的系统调用时，例如`sock.connect()`,`sock.recv()`时，当前线程会释放GIL，让别的线程有执行机会。但是单个线程内，在阻塞调用上还是阻塞的。

> 小提示：Python中 time.sleep 是阻塞的，都知道使用它要谨慎，但在多线程编程中，time.sleep 并不会阻塞其他线程。

除了GIL之外，所有的多线程还有通病。它们是被OS调度，调度策略是抢占式的，以保证同等优先级的线程都有均等的执行机会，那带来的问题是：并不知道下一时刻是哪个线程被运行，也不知道它正要执行的代码是什么。程序员无法控制，所以就可能存在**竞态条件**。

### 非阻塞方式

#### epoll

如果 OS 能判断非阻塞调用是否就绪，是不是应用程序就可以不用自己去等待和判断了，就可以利用这个空闲去做其他事情以提高效率。

**OS将I/O状态的变化都封装成了事件**并且**提供了专门的系统模块让应用程序可以接收事件通知**

#### 回调(Callback)

把I/O事件的等待和监听任务交给了 OS，那 OS 在知道I/O状态发生改变后回调

#### 事件循环（Event Loop）

**等待事件通知的循环，称之为事件循环**。

在单线程内用 **事件循环+回调** 搞定了10篇网页同时下载的问题。这，已经是**异步编程**了

### 小结

不论什么编程语言，但凡要做异步编程，上述的“事件循环+回调”这种模式是逃不掉的

## 协程

#### 基于生成器的协程

生成器（Generator），它的特点和协程很像。每一次迭代之间，会暂停执行，继续下一次迭代的时候还不会丢失先前的状态。

#### 未来对象(Future)

先设计一个对象，异步调用执行完的时候，就把结果放在它里面。这种对象称之为未来对象。未来对象有一个`result`属性，用于存放未来的执行结果。

#### 任务对象(Task)

#### 事件循环(Event Loop)驱动协程运行

只需等待已经注册的`EVENT_WRITE`事件发生。事件循环就像心脏一般，只要它开始跳动，整个程序就会持续运行。

### 用 yield from 改进生成器协程(Python 3.3)

### asyncio库(Python 3.4)

`asyncio`是Python 3.4 试验性引入的异步I/O框架（PEP 3156），提供了基于协程做异步I/O编写单线程并发代码的基础设施。其核心组件有事件循环（Event Loop）、协程(Coroutine）、任务(Task)、未来对象(Future)以及其他一些扩充和辅助性质的模块。

### async/await语法(Python 3.5)

对协程有了明确而显式的支持，称之为**原生协程**。`async/await` 和 `yield from`这两种风格的协程底层复用共同的实现，而且相互兼容。

### `asyncio`成为标准库(Python 3.6)

asyncio深层次地还实现了零拷贝、公平调度、异常处理、任务状态管理等













意味着不要将宝贵的CPU时间浪费在一个被I/O等待的任务，事件循环通过不断轮询任务队列，以确保立即调度并运行一个处于非I/O等待的任务。

异步有助于并发执行。

异步模式用于I/O密集型程序，如爬虫属于I/O密集型，CPU需要大量时间等待网络I/O。

**协程**是一种用关键字async def定义的函数，是Python生成器函数的专用版本，换句话说，协程本质还是一个生成器，我们也可以称一个协程对象是一个任务，当Python执行到await时，当处于I/O等待时会将控制权归还给事件循环。 只有当协程函数封装到task容器后,并由事件循环执行任务调度，协程函数才算真正执行。

**futures**是一种用于托管多个协程对象的并返回其执行结果的(已执行或未执行)的对象。 甚至是某个携程对象出现的异常状态。使用async/await时 会自动创建Future对象，不需要在应用程序级别的代码中创建Future对象

## 异步I/O的思想

异步IO的核心部件是协程函数，它就是一个大型的I/O任务分解成多个的子任务，这些子任务就是用async def 定义的协程函数。每个**协程函数从单次CPU时间的分配来说，实际上也是只执行一次，只要当前协程获得事件循环的优先调度也就获得了CPU时间的分配，由于CPU的切换速度在单个事件循环中是非常快速的，从宏观上说给人一种多个协程函数同时执行的效果**。协程函数内部实质上包含yield执行点，也就是**在Python执行到一个携程函数内部的await关键字所在代码语句处并且处于I/O挂起时，携程函数的上下文切换就会发生，从I/O等待的携程函数会将控制权归还给事件循环，并由事件循环分配给其他就绪的协程函数，反之则不会发生上下文切换**。

async，await其实等价于yield关键字定义一个Python生成器的语法糖，async、await比yield非常友好，它们让程序员像定义同步版本的函数一样编写函数。

> 备注：asyncio中的上下文切换表示事件循环生成从一个协程到下一个协程的控制流。



